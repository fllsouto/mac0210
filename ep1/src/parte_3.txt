Para resolver a terceira e última parte do exercício programa proposto,
utilizamos a seguinte idéia:

O enunciado menciona sobre uma função f(x) de classe C^2 definida em um intervalo
[a, b]. Foi, então, suposto por nós que a e b são números reais, e por serem de classe
C^2, a função f(x) é garantidamente contínua.
Para usar o programa, é necessário fazer as devidas modificações:
1 - Mudar o valor da variável "choice" para um dos valores: 1, 2 ou 3.
1.a - Para choice = 1, o programa considerará a função f(x) = 2cosh(x/4) - x
1.b - Para choice = 2, o programa considerará a função f(x) - sin(x) / x se x != 0 ou f(x) = 1 se x = 0
1.c - Para choice = 3, o programa considerará um polinomio, que deve ser escrito de acordo com a sintaxe
do Octave, na função "function3", no código do programa. Convém que a função que representa o polinomia seja,
no mínimo, de classe C^2, conforme exigência do enunciado (isso fica a cargo do usuário e não do programa).
2 - Mudar os valores das variáveis "lower_edge" e "higher_edge" (estas fazem os papeis de a e b do enunciado, respectivamente).
3 - Mudar o valor da variável n_inter para o número de partições (sub-intervalos) em que o intervalo [a, b] deve ser dividido.
4 - Mudar a tolerância "tol" do erro para aceitar o valor calculado pelo método de Newton como significativamente próximo ao valor real da raíz.
Finalmente, atribuídos os valores iniciais, o programa vai realizar a tarefa que foi designada a nós no enunciado da seguinte maneira:
Será invocado o método "intervals", que é onde tudo acontecerá. Deve-se escolher o tamanho dos passos (= steps, caso não goste do que está
escrito no código).
A variável "range" conterá todos os pontos x de f(x) que deverão ser testados para encontrar a raíz.
A variável "sub_interval" serve para monitorar qual é o número do intervalo em que o ponto x que está sendo testado está.
A variável "sub_inter_length" guarda o tamanho das partições, enquanto as variáveis "sub_lower_edge" e "sub_higher_edge"
guardam os limites da participação atual (em que o programa se encontra em tempo de execução).
Nota: Para um intervalo [a, e] dividido em 4 partes, as partições de [a, e] são [a, b]; ]b, c]; ]c, d], ]d, e]. Note que
apenas a primeira partição possui o inteiro limitante inferior.

Em seguida, o primeiro valor de x de todos é avaliado em f(x) separadamente para obtermos o sinal inicial de f(x). Se dermos sorte
e o primeiro valor já for zero, é que o primeiro ponto é uma raiz. Neste caso, haverá uma impressão do intervalo,
o número do intervalo e o valor da raíz no terminal.
Note: O valor 1 representa sinal não negativo e o valor 2 representa sinal negativo.
Obtido o sinal, o programa entra em um loop que vai do segundo ao penúltimo valor de x. Sempre que o valor do sinal de f(x) do novo
x mudar em relação ao anterior (isto é, ir de positivo para negativo ou de negativo para positivo). Se zero for encontrado, é que o próprio x é
uma raiz, e nesse caso o sinal é considerado positivo, as informações são impressar e o laço já recomeça a próxima iteração, sem rodar
o método de Newton. Agora se acontecer uma mudança de sinal, significa que existe uma raiz entre o último x e o atual, e nesse caso
aplicamos o método de Newton para buscar uma aproximação do valor real da raiz considerando a tolerância tol. Se a cada iteração o decrescimento
não for significativo (isto é, nosso ponto de partida X não é tão bom e portanto não estamos conseguindo aproximações expressivas do valor real da raíz),
o método de Newton será interrompido e um novo valor do x atual será buscado pelo método da biseção (que fará 3 iterações apenas, conforme o enunciado
pede). Encontrado o novo valor de x pelo método da biseção, usamos este valor como entrada do método de Newton e assim obteremos, eventualmente, a nova
raíz até então desconhecida. Ao encontrar a raíz, assim como nas vezes anteriores, será impresso no terminal as suas informações.
Isso é repetido até que chegamos, finalmente, ao final da iteração do penúltimo valor de X a ser testado, finalizando assim o loop principal do programa.
Após o loop, é checado separadamente o último valor de x, comnsiderando o penúltimo valor de x.

O código pertinente a esta parte está bastante comentado, então entendendo esta explicação e acompanhando o código deve ser mais que o
suficiente para entender a implementação sem maiores dificuldades.
